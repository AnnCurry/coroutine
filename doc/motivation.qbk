[/
          Copyright Oliver Kowalke 2009.
 Distributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at
          http://www.boost.org/LICENSE_1_0.txt
]

[section:motivation Motivation]

In order to support a broad range of execution control behaviour the coroutine
types of __scoro__ and __acoro__ can be used to ['escape-and-reenter] loops, to
['escape-and-reenter] recursive computations and for ['cooperative] multitasking
helping to solve problems in a much simpler and more elegant way than with only
a single flow of control.

[heading event-driven model]

In the event-driven model the flow of a program is determined by events. The
events are generated by multiple independent sources. A main event-loop,
waiting on all external sources, triggers callback functions if one of those
events is detected.
The application is divided into event selection (detection) and event
handling.
The downside of the event-driven model consists in a sub-optimal program
structure. A event-driven program is required to split its code into
multiple small callback functions. A algorithm that would usually expressed as
a sequence of functions and loops must be transformed into callbacks. The
complete state has to be stored into a data structure while the control flow
returns to the event-loop.

        class session : public std::enable_shared_from_this<session>
        {
        public:
            session(tcp::socket socket) :
                socket_(std::move(socket))
            {}

            void start()
            { do_read(); }

        private:
            void do_read()
            {
              auto self(shared_from_this());
              socket_.async_read_some(boost::asio::buffer(data_, max_length),
                  [this, self](boost::system::error_code ec, std::size_t length)
                  {
                    if (!ec) do_write(length);
                  });
            }

            void do_write(std::size_t length)
            {
              auto self(shared_from_this());
              boost::asio::async_write(socket_, boost::asio::buffer(data_, length),
                  [this, self](boost::system::error_code ec, std::size_t /*length*/)
                  {
                    if (!ec)
                      do_read();
                  });
            }

            tcp::socket socket_;
            enum { max_length = 1024 };
            char data_[max_length];
        }; 

The use of local variables, while/for loops, recursions etc. together with the
event-loop is not possible. The code becomes less expressive.
A combination of event-driven model and coroutines removes the drawbacks and
enables to write code.

        void session( socket_ptr sock)
        {
            try 
            {   
                for (;;)
                {   
                    char data[max_length];
                    
                    boost::system::error_code ec;
                    std::size_t length = sock->async_read_some(
                            boost::asio::buffer( data),
                            boost::asio::yield[ec]);
                    if ( ec == boost::asio::error::eof)
                        break; //connection closed cleanlyby peer
                    else if ( ec)
                        throw boost::system::system_error( ec); //some other error
                      
                    boost::asio::async_write(
                            * sock,
                            boost::asio::buffer( data, length),
                            boost::asio::yield[ec]);
                    if ( ec == boost::asio::error::eof)
                        break; //connection closed cleanlyby peer
                    else if ( ec)
                        throw boost::system::system_error( ec); //some other error
                }     
            }         
            catch ( std::exception const& e)
            { std::cerr << "Exception in fiber: " << e.what() << "\n"; }
        }  

[endsect]
