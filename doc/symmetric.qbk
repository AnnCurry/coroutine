[/
          Copyright Oliver Kowalke 2009.
 Distributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at
          http://www.boost.org/LICENSE_1_0.txt
]

[section:symmetric Symmetric coroutine]

In contrast to asymmetric coroutines, were the relationship between caller and
callee ist fixed, are symmetric coroutines capable to transfer execution control
to any other (symmetric) coroutine. E.g. a symmetric coroutine is not required
to return to its caller.


[heading __call_coro___]
__call_coro___ starts a symmetric coroutine and transfers parameter to its
__coro_fn__.
The first template parameter defining the transferred parameter type.
The constructor of __call_coro___ takes a function (__coro_fn__) accepting a
reference to a __yield_coro__ as argument. Instantiating a __call_coro___ does
not pass the control of execution to __coro_fn__ - instead the first call of
__call_coro_op__ synthesizes a __yield_coro__ passed it as reference to
__coro_fn__.

The interface does not contain a ['get()]-function: you can not retrieve
values from another execution context with this kind of coroutine.


[heading __yield_coro__]
__yield_coro_op__ ist used to transfers data and execution control to another
context - which might be a __call_coro___ or called with no argument back to the
excecution context were the chain of symmetric coroutines has been started
(invocation of __call_coro_op__).
The class has only one template parameter defining the transferred parameter
type.
Data transferred to the coroutine are accessed through __yield_coro_get__.


[heading coroutine-function]
The __coro_fn__ returns ['void] and takes __yield_coro__, providing
coroutine functionality inside the coroutine-fn, as argument, so that using this
instance passed as argument to __coro_fn__ is the only way to transfer data and
execution control.
__call_coro___ does not enter the __coro_fn__ at __call_coro___ construction but
entered by the first invocation of __call_coro_op__.


[heading passing data from main-context to a symmetric-coroutine]
In order to transfer data to a __call_coro___ from the main-context the framework
synthesizes a __yield_coro__ associated with the __call_coro___ instance in the
main-context. The synthesized __yield_coro__ is passed as argument to
__coro_fn__.
The main-context must call __call_coro_op__ in order to transfer each data value
into the __coro_fn__.
Access to the transferred data value is given by __yield_coro_get__.

        boost::coroutines::symmetric_coroutine<int>::call_type coro( // constructor does NOT enter coroutine-function
            [&](boost::coroutines::symmetric_coroutine<int>::yield_type& yield){
                for (;;) {
                    std::cout << yield.get() <<  " ";
                    yield(); // jump back to starting context
                 }
            });

        coro(1); // transfer {1} to coroutine-function
        coro(2); // transfer {2} to coroutine-function
        coro(3); // transfer {3} to coroutine-function
        coro(4); // transfer {4} to coroutine-function
        coro(5); // transfer {5} to coroutine-function


[heading exceptions]
An exception thrown and not catched inside a __call_coro___'s __coro_fn__ will call
__terminate__.

[important Code executed by coroutine must not prevent the propagation of the
__forced_unwind__ exception.  Absorbing that exception will cause stack
unwinding to fail.  Thus, any code that catches all exceptions must re-throw the
pending exception.]

        try {
            // code that might throw
        } catch(const forced_unwind&) {
            throw;
        } catch(...) {
            // possibly not re-throw pending exception
        }


[heading Stack unwinding]
Sometimes it is necessary to unwind the stack of an unfinished coroutine to
destroy local stack variables so they can release allocated resources (RAII
pattern). The third argument of the coroutine constructor, `do_unwind`,
indicates whether the destructor should unwind the stack (stack is unwound by
default).

Stack unwinding assumes the following preconditions:

* The coroutine is not __not_a_coro__
* The coroutine is not complete
* The coroutine is not running
* The coroutine owns a stack

After unwinding, a __coro__ is complete.

        struct X {
            X(){
                std::cout<<"X()"<<std::endl;
            }

            ~X(){
                std::cout<<"~X()"<<std::endl;
            }
        };

        boost::coroutines::symmetric_coroutine<int>::call_type other_coro(...);

        {
            boost::coroutines::symmetric_coroutine<void>::call_type coro(
                [&](boost::coroutines::symmetric_coroutine<void>::yield_type& yield){
                    X x;
                    std::cout<<"fn()"<<std::endl;
                    // transfer execution control to other coroutine
                    yield( other_coro, 7);
                });

            coro();

            std::cout<<"coro is complete: "<<std::boolalpha<<!coro<<"\n";
        }

        std::cout<<"Done"<<std::endl;

        output:
            X()
            fn()
            coro is complete: false
            ~X()
            Done


[heading Exit a __coro_fn__]
__coro_fn__ is exited with a simple return statement jumping back to the calling
__call_coro_op__ at the start of symmetric coroutine chain. E.g. symmetric coroutines do
not have a strong, fixed relationship to the caller as asymmetric coroutines.
The __call_coro___ becomes complete, e.g. __call_coro_bool__ will return 'false'.

[important After returning from __coro_fn__ the __coro__ is complete (can not
resumed with __call_coro_op__).]



[section:yield_coro Class `symmetric_coroutine<>::yield_type`]

    #include <boost/coroutine/symmetric_coroutine.hpp>

    template< typename R, typename StackAllocator = standard_stack_allocator >
    class symmetric_coroutine<>::yield_type
    {
    public:
        yield_type( yield_type const& other)=delete;

        yield_type & operator=( yield_type const& other)=delete;

        yield_type( yield_type && other) noexcept;

        yield_type & operator=( yield_type && other) noexcept;

        void swap( yield_type & other) noexcept;

        yield_type & operator()();

        template< typename X >
        yield_type & operator()( symmetric_coroutine< X > & other, X & x);

        template< typename X >
        yield_type & operator()( symmetric_coroutine< X > & other);

        R get() const noexcept;
    };

    template< typename R >
    void swap( symmetric_coroutine< R >::yield_type & l, symmetric_coroutine< R >::yield_type & r);

[heading `yield_type( yield_type && other)`]
[variablelist
[[Effects:] [Moves the internal data of `other` to `*this`.
`other` becomes __not_a_coro__.]]
[[Throws:] [Nothing.]]
]

[heading `yield_type & operator=( yield_type && other)`]
[variablelist
[[Effects:] [Destroys the internal data of `*this` and moves the
internal data of `other` to `*this`. `other` becomes __not_a_coro__.]]
[[Throws:] [Nothing.]]
]

[heading `operator unspecified-bool-type() const`]
[variablelist
[[Returns:] [If `*this` refers to __not_a_coro__, the function returns false.
Otherwise true.]]
[[Throws:] [Nothing.]]
]

[heading `bool operator!() const`]
[variablelist
[[Returns:] [If `*this` refers to __not_a_coro__, the function returns true.
Otherwise false.]]
[[Throws:] [Nothing.]]
]

[heading `yield_type & operator()()`]
[variablelist
[[Preconditions:] [`*this` is not a __not_a_coro__.]]
[[Effects:] [Execution control is transferred back to the starting point,
e.g. invocation of __call_coro_op__.]]
[[Throws:] [Exceptions thrown inside __coro_fn__.]]
]

[heading `R get()()`]

    R    symmetric_coroutine<R>::yield_type::get();
    R&   symmetric_coroutine<R&>::yield_type::get();
    void symmetric_coroutine<void>yield_type::get()=delete;

[variablelist
[[Preconditions:] [`*this` is not a __not_a_coro__.]]
[[Returns:] [Returns data transferred from coroutine-function via
__push_coro_op__.]]
[[Throws:] [Nothing.]]
]

[heading `void swap( yield_type & other)`]
[variablelist
[[Effects:] [Swaps the internal data from `*this` with the values
of `other`.]]
[[Throws:] [Nothing.]]
]

[heading Non-member function `swap()`]

    template< typename R >
    void swap( symmetric_coroutine< R >::yield_type & l, symmetric_coroutine< R >::yield_type & r);

[variablelist
[[Effects:] [As if 'l.swap( r)'.]]
]

[endsect]


[section:symmetric_coro Class `symmetric_coroutine<>`]

    #include <boost/coroutine/symmetric_coroutine.hpp>

    template< typename Arg, typename StackAllocator = standard_stack_allocator >
    class symmetric_coroutine<>::call_type
    {
    public:
        call_type();

        template< typename Fn >
        call_type( Fn fn, attributes const& attr = attributes() );

        template< typename Fn >
        call_type( Fn && fn, attributes const& attr = attributes(),
                   StackAllocator stack_alloc = StackAllocator() );

        call_type( call_type cosnt& other)=delete;

        call_type & operator=( call_type const& other)=delete;

        call_type( call_type && other);

        call_type & operator=( call_type && other);

        ~call_type();

        operator unspecified-bool-type() const;

        bool operator!() const;

        void swap( call_type & other);

        call_type & operator()( Arg&& arg);
    };

    template< typename Arg >
    void swap( symmetric_coroutine< Arg >::call_type & l, symmetric_coroutine< Arg >::call_type & r);

[heading `call_type()`]
[variablelist
[[Effects:] [Creates a coroutine representing __not_a_coro__.]]
[[Throws:] [Nothing.]]
]

[heading `template< typename Fn, typename StackAllocator >
          call_type( Fn fn, attributes const& attr, StackAllocator const& stack_alloc)`]
[variablelist
[[Preconditions:] [`size` > minimum_stacksize(), `size` < maximum_stacksize()
when ! is_stack_unbound().]]
[[Effects:] [Creates a coroutine which will execute `fn`. Argument `attr`
determines stack clean-up and preserving floating-point registers.
For allocating/deallocating the stack `stack_alloc` is used.]]
]

[heading `template< typename Fn, typename StackAllocator >
          call_type( Fn && fn, attributes const& attr, StackAllocator const& stack_alloc)`]
[variablelist
[[Preconditions:] [`size` > minimum_stacksize(), `size` < maximum_stacksize()
when ! is_stack_unbound().]]
[[Effects:] [Creates a coroutine which will execute `fn`. Argument `attr`
determines stack clean-up and preserving floating-point registers.
For allocating/deallocating the stack `stack_alloc` is used.]]
]

[heading `call_type( call_type && other)`]
[variablelist
[[Effects:] [Moves the internal data of `other` to `*this`.
`other` becomes __not_a_coro__.]]
[[Throws:] [Nothing.]]
]

[heading `call_type & operator=( call_type && other)`]
[variablelist
[[Effects:] [Destroys the internal data of `*this` and moves the
internal data of `other` to `*this`. `other` becomes __not_a_coro__.]]
[[Throws:] [Nothing.]]
]

[heading `operator unspecified-bool-type() const`]
[variablelist
[[Returns:] [If `*this` refers to __not_a_coro__ or the coroutine-function
has returned (completed), the function returns false. Otherwise true.]]
[[Throws:] [Nothing.]]
]

[heading `bool operator!() const`]
[variablelist
[[Returns:] [If `*this` refers to __not_a_coro__ or the coroutine-function
has returned (completed), the function returns true. Otherwise false.]]
[[Throws:] [Nothing.]]
]

[heading `call_type<> & operator()(Arg&& arg)`]

        symmetric_coroutine::call_type& coroutine<Arg>::call_type::operator()(const Arg&);
        symmetric_coroutine::call_type& coroutine<Arg>::call_type::operator()(Arg&&);
        symmetric_coroutine::call_type& coroutine<Arg&>::call_type::operator()(Arg&);
        symmetric_coroutine::call_type& coroutine<void>::call_type::operator()();

[variablelist
[[Preconditions:] [operator unspecified-bool-type() returns true for `*this`.]]
[[Effects:] [Execution control is transferred to __coro_fn__ and the argument
`arg` is passed to the coroutine-function.]]
[[Throws:] [Exceptions thrown inside __coro_fn__.]]
]

[heading `void swap( call_type & other)`]
[variablelist
[[Effects:] [Swaps the internal data from `*this` with the values
of `other`.]]
[[Throws:] [Nothing.]]
]

[heading Non-member function `swap()`]

    template< typename Arg >
    void swap( symmetric_coroutine< Arg >::call_type & l, symmetric_coroutine< Arg >::call_type & r);

[variablelist
[[Effects:] [As if 'l.swap( r)'.]]
]

[endsect]



[endsect]
